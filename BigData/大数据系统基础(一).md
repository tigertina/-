<font face="微软雅黑">
### 大数据系统基础（一）

### 1.绪论

数据科学：从数据中提取价值。

数据的5V特点（IBM提出）：

* Volume（大量），数据的大小决定所考虑的数据的价值和潜在的信息
* Velocity（高速），指获得数据的速度
* Variety（多样），数据类型的多样性
* Value（价值），合理运用大数据，以低成本创造高价值
* Veracity（真实性），数据的质量

极端规模的并行化：仓库规模的计算机

* 使用相对同质的硬件和系统软件平台
* 共享相同的系统管理
* 大多数应用程序、中间件、系统软件都是自主开发
* WSC运行相对小数目的超大型程序
* 通用的资源管理架构增强了部署的灵活

云计算：既指作为服务通过互联网提供的应用程序，又指提供这些服务的，位于数据中心的硬件和系统软件。

商业模式：按需服务，资源池，可测量的服务


###3. 文件存储

####3.3 文件系统接口标准化
虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，他对Linux的每个文件系统的所有细节进行抽象，使得不同的文件系统在Linux核心以及系统中运行的其他进程看来，都是相同。

####3.4 文件系统的磁盘数据结构
文件系统在磁盘中的数据组织

文件系统的名字解析

数据块 4KB

inode 获取文件信息owner、address、ctime，不包括文件内容，

/home/mike/a.txt 存在目录树下
![](http://i.imgur.com/ntamN6Q.png)

####3.5 文件系统讨论
* 磁盘块大小
按块读取
* 文件系统的缓存
缓冲能够加速的必须条件，时间局部性（同一文件可能会被再次访问）与空间局部性（相邻文件可能会被访问）
* 磁盘优化策略
磁盘的顺序读写与随机读写

####3.6 分布式文件系统与本地文件系统
分布式文件系统需要提供：

* 文件系统目录树
* 文件读写

本质：将一个以目录树表达的文件翻译为一个具体的节点，而到磁盘的定位则可以交给本地文件系统去完成。

####3.7 最简单的分布式文件系统NFS（网络文件系统）

无需进行分布式环境的定位，所有的文件都保存在一个服务器中。

AFS扩展NFS，多个服务器
####3.8 Google文件系统
为什么需要不同的分布式文件系统

* 为了建立搜索引擎，需要存储互联网的数据，支持数据快速写入
* 为了支持查询，需要对大量数据进行处理，需要建立倒排索引，对网页数据进行排序
* 都是应用驱动的，需要建立一个新的分布式系统

**Google文件系统设计**

* 数据块 64MB 这个数据块大小远远大于一般的文件系统数据块的大小
* 性能设计 自动调整数据在不同服务器中的存放，服务器存储利用率相似，负载动态调整
* 可靠性 保存3个节点以上
* 简化 master 通过单个节点来保存文件系统的元数据

**分布式文件系统的基本设计**

![](http://i.imgur.com/qpZBW5N.png)

**GFS性能问题**

* 块服务器的负载均衡  不能让一块块服务器出现性能瓶颈，负载必须进行动态调整
* 块服务器的扩展  由master进行管理
* 主服务器的性能负载均衡  容量问题，元数据的计算过程（可以将元数据放到内存，加快速度）
	* 64MB数据块需要64B的元数据

**可靠性问题**

* 块服务器可靠性 如果块服务器出现错误，那么并行恢复，恢复时间很快。
* 主服务器的可靠性 把写操作日志写入磁盘，保证内存数据丢失，恢复主服务器。
* 定期快照内存元数据，这样可以快速恢复。定期内存镜像。
* 影子服务器  所有操作都要发送给影子服务器

**Google一致性要求**

* 传统的文件系统的一致性体现（一份数据的隐含地址操作）
* 三副本一致性的基本要求
* 更改数据的操作（读操作不会影响一致性）
* 如何写入过程，保证三个副本一样
	* 按照相同的操作顺序执行客户端的操作
	* master委托主要副本，给一个租期，这个主要副本的顺序定义

**GFS中的放松的一致性**

GFS的用户是搜索引擎，并不关注数据写到哪里

Append 是个原子操作，不知道写入位置

![](http://i.imgur.com/iZ0ekSk.png)

GFS 分布式文件的垃圾收集

* 删除的数据不是直接从本地文件系统中删除，而是通过垃圾收集的方法，比传统的方法简单，并更加可靠
* 主服务器要日志记录删除操作，并将文件改名成隐藏的文件名
* 在系统负载不高的时候后台回收隐藏的文件

**数据不能改，只能添加**

###4. 处理框架

####4.1 大数据的处理框架
思想：数据并行

**数据并行化（DLP）**
若干硬盘的大量数据，可以被并行化的操作（比如，搜索文档）Embarrassingly Parallel

* MapReduce

* Pig Latin

####4.2 MapReduce编程模型
* Map 将数据分割成shards或者splits，将它们分配给工作节点，工作节点来计算子问题的解。
	* map(in_key,in_value)->list(out_key,intermediate_ value)
	* 处理输入的键值对
	* 生成中间结果集
* Reduce  收集
	* reduce(out_key,list(intermediate_value))->list(out_key)
	
![](http://i.imgur.com/stHNrZq.png)

####4.3 MapReduce执行步骤
* 将输入数据分割成M块，在每块上分布式地调用map()
	* 通常每个数据块16MB或者64MB
	* 取决于GFS的数据块大小

* 输入数据由不同服务器处理
* 通过将中间结果分割成R块，对每块分布式调用Reduce()
* M和R数量用户指定
	* M >> #servers, R > #server
	* 很大的M有助于负载均衡，以及快速恢复
	* 每个Reduce()调用，对应一个单独的输出文件，所以R值不应该太大

map计算完成以后，调用emit，然后计算出shard，这个shard对应reduce

只有这一步是经历了网络通讯，除了读取GFS文件

![](http://i.imgur.com/teSRHIk.png)

####4.4 MapReduce数据流
![](http://i.imgur.com/BecVXKy.png)
绿色的都是进程

####4.5 MapReduce性能优化与容错
* MapReduce冗余执行
	* 在接近结束时候，生成冗余任务，谁先跑完，谁获胜
	* 也叫作“投机”执行
	* 每个操作都是幂等的，执行一次或多次都可以。
* 如果master出错，那就重新跑

####4.6 Hadoop MapReduce的开源实现
Google的MapReduce基于GFS，Google的一系列分布式系统。

Hadoop MapReduce的基本架构

* JobTracker（Master）
* TaskTracker（Worker）